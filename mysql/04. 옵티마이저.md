> 내용 참고 : [Real MySQL 8.0 (1권)](https://www.yes24.com/Product/Goods/103415627)

# 04. 옵티마이저

# 1. 옵티마이저
- DB 서버에서 두뇌와 같은 역할 담당

## 1-1. 쿼리 실행 절차
1. `[Parse Tree 생성]` 요청된 SQL 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리 - `SQL 파서 이용`
2. `[실행 계획 생성]` Parse Tree 확인 하면서 어떤 테이블부터 읽고 어떤 인덱스 사용할 지 선택 - `최적화 및 실행 계획 수립 단계`
   - 불필요 조건 제거 및 연산 단순화
   - 여러 테이블 조인 시 순서 결정
   - 통계 정보 이용하여 사용할 인덱스 결정
   - 가져온 레코드 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정
3. `[데이터 조회]` 두 번째에서 결정된 읽기 순서와 인덱스 이용하여 `스토리지 엔진`으로부터 데이터 가져옴

<br />

## 1-2. 옵티마이저 종류

### 1) CBO(Cost-based optimizer) - 비용 기반 최적화
- 각 작업의 비용 정보, 대상 테이블의 예측된 통계 정보를 이용하여 계획별 비용 산출
- 산출된 여러 개 실행 방법들 중 최소 비용 처리방식 선택

<br />

### 2) RBO(Rule-based optimizer) - 규칙 기반 최적화
- 레코드 건수나 선택도 고려하지 않고 `옵티마이저`에 내장된 `우선순위`에 따라 실행 계획 수립하는 방식
- 거의 항상 같은 실행 계획을 만들어내며 잘 사용하지 않음

<br />

# 2. 기본 데이터 처리

<br />

## 2-1. 병렬 처리
- MySQL 8.0 와서 하나의 쿼리에 여러 스레드가 작업을 나누어 동시 처리가 가능해졌다.
- 여러 개의 쿼리가 동시에 처리된다는 얘기가 아니다 (이건 옛날부터 가능했다)

<br />

## 2-2. ORDER BY 처리 (filesort)
- Order by 처리할 때 인덱스가 있다면 인덱스를 이용하고, 없다면 `Filesort`를 이용한다. 
1) `index` : 빠르다, 그러나 insert, update, delete 작업 시 인덱스도 추가해야 하기 때문에 느리다. 인덱스 공간을 차지한다.
   - 이미 index는 정렬되어 있기 때문에 order by 쿼리 실행 시에 추가적인 처리 과정이 필요없다. 
2) `filesort` : 정렬할 레코드가 많지 않으면 메모리에서 filesort 되기 때문에 충분히 빠르다.  
   - order by 작업은 쿼리 실행 시에 일어나기 때문에 레코드가 많다면 느리다.

<br />

### 🔵 인덱스가 좋긴 하지만 사용할 수 없어서 filesort 해야하는 경우가 있다
1) 정렬 기준이 많아서 모두 인덱스 생성이 힘든 경우
2) `group by` 혹은 `distinct` 중복 제거된 이후 정렬을 할 때
3) `UNION` 사용하여 임시 테이블의 결과를 다시 정렬해야할 때
4) 랜덤하게 결과 레코드를 가져와야할 때

<br />

### 🔵 소트 버퍼
- 정렬을 수행하기 위한 별도의 메모리 공간을 말한다.
- 일반적으로 정렬 시에 이 소트 버퍼(메모리)를 사용하겠지만 이것보다 더 큰 데이터를 정렬해야 한다면 여러 조각으로 나눠서 처리하는데, 이 때 임시저장 위해 디스크 사용
- 즉, `소트 버퍼`에서 정렬 수행 후 그 결과를 디스크에 기록, 계속해서 `소트 버퍼`만큼 가져와서 정렬하고 디스크에 기록 (버퍼 크기만큼 디스크에 병합)
  - 이를 `멀티 머지(Multi-merge)` 라고 한다.
- 소트 버퍼의 적정한 사이즈는 `256KB 이상 8MB 미만`
- 소트 버퍼는 매 커넥션마다 생성하기 때문에 크게 잡으면 요청이 많이 일어나고 대량으로 정렬할 시에 MySQL 자체가 죽을 수 있다. (OOM)

### 🔵 Order by 정렬 알고리즘
- `SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G` 쿼리로 확인 가능

1. 싱글 패스
   - `<sort_key, rowid>` : 정렬 키와 row ID만 가져와서 정렬 
   - `쿼리 실행` -> `모든 컬럼 조회 & 소트 버퍼 담고 정렬` -> `정렬 결과 그대로 클라이언트 전달`
2. 투 패스
   - `<sort_key, additional_fields>` : 정렬 키와 레코드 전체를 가져와서 정렬 (레코드 컬럼은 고정 사이즈로 메모리 저장)
   - `<sort_key, packed_additional_fields>` : 정렬 키와 레코드 전체를 가져와서 정렬 (레코드 컬럼은 가변 사이즈로 메모리 저장)
   - `쿼리 실행` -> `정렬에 필요한 컬럼만 조회 후 소트 버퍼에 담고 정렬` -> `정렬 결과 순서대로 테이블 한번 더 읽어서 정렬 외 추가 컬럼 가져옴` -> `결과 클라이언트 전달` 

> 투 패스 방식은 테이블을 두 번 읽어야 해서 불합리적
   
<br />

### 🔵 정렬 처리 방법
1. 인덱스 사용 정렬 (`별도 표기 없음`) - 가장 빠름
   - Order by 순서대로 생성된 인덱스가 있어야 한다. 
   - `Nested Loop` 방식의 조인, `B-Tree` 계열 인덱스만 사용 가능하다.
   - 실제 인덱스대로 정렬 되어 있기 때문에 그대로 읽기만 하면 된다.
2. 조인에서 드라이빙 테이블만 정렬 (`Using filesort`)
3. 조인해서 결과를 임시테이블로 저장 후 정렬 (`Using temporary; Using filresort`)


