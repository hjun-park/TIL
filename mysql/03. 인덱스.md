# 03. 인덱스

- 인덱스는 데이터베이스의 검색 속도를 높이기 위해 사용하는 기술이다.
- 인덱스는 `INSERT, UPDATE, DELETE` 성능을 희생하고 `SELECT` 읽기 성능을 높이는 기능이다.
- `WHERE`절에 온다고 모두 `INDEX`를 걸면 `INSERT, UPDATE, DELETE` 성능이 떨어지고 인덱스 크기만 커진다.

#### 🔵 인덱스 저장 방식(알고리즘)에 따른 분류

1. `B-Tree` 알고리즘 : 컬럼의 값을 변형하지 않고 원래 값을 이용해 인덱싱하는 알고리즘
    - `MySQL`에서 위치기반 검샋 지원 위한 `R-Tree` 인덱스 알고리즘도 제공한다. (`B-Tree` 응용)
2. `Hash` 알고리즘 : 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘
    - `Hash` 알고리즘은 `=`와 `IN` 연산자만 사용하는 동등 비교에만 사용할 수 있다.

<br />

#### 🔵 데이터 중복 허용 여부에 따른 분류

1. `Unique index` : 중복된 값을 가질 수 없다.
    - 옵티마이저에게 알려줘 1건만 찾으면 다른건 찾지 않아도 된다는 것을 알려준다.
2. `Non-Unique index` : 중복된 값을 가질 수 있다.

# 1. 인덱스 종류

## 1-1. B-Tree 인덱스

- `B-Tree` 인덱스는 컬럼의 값을 변형하지 않고 원래 값을 이용해 인덱싱하는 알고리즘이다.
- `Binary`가 아닌 `Balanced` 트리이다, 항상 정렬된 상태를 가진다.
- `B+-Tree`, `B*-Tree`도 사용된다.

<br />

### 1) B-Tree 인덱스 구조

<div style="text-align: center;">
   <img src="https://github.com/hjun-park/kothe/assets/70880695/1ca30a7c-f019-4cf9-b066-6f176d1bf602" width="70%" height="70%">
</div>

- `B-Tree` 인덱스 최상위에 `Root node`가 존재하고 그 하위에 자식 노드가 붙어 있다.
- `Root node` - `Branch node` - `Leaf node`로 구성되어 있다.
- 인덱스의 `Leaf node`에는 실제 데이터 레코드를 찾아가기 위한 주솟값이 있다.

<br />

### 2) B-Tree 인덱스 동작
1. `[추가]` `B-Tree` 인덱스는 `INSERT`나 `UPDATE`로 인해 인덱스 키가 추가되면 `B-Tree` 구조를 유지하기 위해 추가 작업이 필요하다. (비용이 듦)
2. `[삭제]` 해당 키 값이 저장된 `B-Tree`의 `Leaf node`를 찾아서 삭제 마크를 한다.
3. `[변경]` 단순히 인덱스상 키 값을 변경할 순 없고, 삭제하고 다시 추가해야 한다.
4. `[검색]` `B-Tree` 인덱스는 항상 정렬된 상태이므로 `Root node`에서부터 시작해 `Branch node`를 타고 `Leaf node`까지 이동하면서 값을 찾아간다.
   - InnoDB 스토리지 엔진의 경우 레코드 락이나 넥스트 키랍(갭락)이 검색을 수행한 인덱스를 잠근다.
   - 인덱스를 잠그고 이후 테이블의 레코드를 잠그는 방식으로 구현되어 잇다.
   - 하지만 `update`, `delete`문 실행 시 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다.
   - 그래서 인덱스를 적절히 잘 걸어야 한다.
    
<br />

### 3) B-Tree 인덱스 성능 영향 요소
1. 인덱스 키 값 크기
   - `페이지` 혹은 `블록` : 디스크에 데이터를 저장하는 가장 기본적인 단위
   - `InnoDB` 스토리지 엔진 페이지 기본 크기 : `16KB`
   - 일반적으로 페이지 당 가질 수 있는 인덱스 키 개수 : `16 * 1024/(16+12) = 585`
   - 키 값의 크기가 2배(32KB)일 때의 한 페이지 당 인덱스 키 개수 : `16 * 1024/(32+12) = 372`
   - 만약 SELECT 쿼리가 레코드 500개 읽어야 한다면 16KB 기준은 1번, 32KB 기준은 2번 읽어야 한다.
> 즉, 하나의 레코드에 저장되는 인덱스의 키가 커질 수록, 메모리에 캐싱할 수 있는 레코드 수가 감소, 결국 메모리 효율 떨어진다.

<br />

#### 🔵 언제 하나의 레코드에 저장되는 인덱스의 키가 커지는가 ?
- 컬럼의 데이터타입이 커지거나 / 다중 컬럼 인덱스를 사용할 때

<br />


