> 내용 참고 : [Real MySQL 8.0 (1권)](https://www.yes24.com/Product/Goods/103415627)

# 03. 인덱스

- 인덱스는 데이터베이스의 검색 속도를 높이기 위해 사용하는 기술이다.
- 인덱스는 `INSERT, UPDATE, DELETE` 성능을 희생하고 `SELECT` 읽기 성능을 높이는 기능이다.
- `WHERE`절에 온다고 모두 `INDEX`를 걸면 `INSERT, UPDATE, DELETE` 성능이 떨어지고 인덱스 크기만 커진다.

#### 🔵 인덱스 저장 방식(알고리즘)에 따른 분류

1. `B-Tree` 알고리즘 : 컬럼의 값을 변형하지 않고 원래 값을 이용해 인덱싱하는 알고리즘
    - `MySQL`에서 위치기반 검샋 지원 위한 `R-Tree` 인덱스 알고리즘도 제공한다. (`B-Tree` 응용)
2. `Hash` 알고리즘 : 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘
    - `Hash` 알고리즘은 `=`와 `IN` 연산자만 사용하는 동등 비교에만 사용할 수 있다.

<br />

#### 🔵 데이터 중복 허용 여부에 따른 분류

1. `Unique index` : 중복된 값을 가질 수 없다.
    - 옵티마이저에게 알려줘 1건만 찾으면 다른건 찾지 않아도 된다는 것을 알려준다.
2. `Non-Unique index` : 중복된 값을 가질 수 있다.

# 1. 인덱스 종류

## 1-1. B-Tree 인덱스

- `B-Tree` 인덱스는 컬럼의 값을 변형하지 않고 원래 값을 이용해 인덱싱하는 알고리즘이다.
- `Binary`가 아닌 `Balanced` 트리이다, 항상 정렬된 상태를 가진다.
- `B+-Tree`, `B*-Tree`도 사용된다.

<br />

### 1) B-Tree 인덱스 구조

<div style="text-align: center;">
   <img src="https://github.com/hjun-park/kothe/assets/70880695/1ca30a7c-f019-4cf9-b066-6f176d1bf602" width="70%" height="70%">
</div>

- `B-Tree` 인덱스 최상위에 `Root node`가 존재하고 그 하위에 자식 노드가 붙어 있다.
- `Root node` - `Branch node` - `Leaf node`로 구성되어 있다.
- 인덱스의 `Leaf node`에는 실제 데이터 레코드를 찾아가기 위한 주솟값이 있다.

<br />

### 2) B-Tree 인덱스 동작

1. `[추가]` `B-Tree` 인덱스는 `INSERT`나 `UPDATE`로 인해 인덱스 키가 추가되면 `B-Tree` 구조를 유지하기 위해 추가 작업이 필요하다. (비용이 듦)
2. `[삭제]` 해당 키 값이 저장된 `B-Tree`의 `Leaf node`를 찾아서 삭제 마크를 한다.
3. `[변경]` 단순히 인덱스상 키 값을 변경할 순 없고, 삭제하고 다시 추가해야 한다.
4. `[검색]` `B-Tree` 인덱스는 항상 정렬된 상태이므로 `Root node`에서부터 시작해 `Branch node`를 타고 `Leaf node`까지 이동하면서 값을 찾아간다.
    - InnoDB 스토리지 엔진의 경우 레코드 락이나 넥스트 키랍(갭락)이 검색을 수행한 인덱스를 잠근다.
    - 인덱스를 잠그고 이후 테이블의 레코드를 잠그는 방식으로 구현되어 잇다.
    - 하지만 `update`, `delete`문 실행 시 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다.
    - 그래서 인덱스를 적절히 잘 걸어야 한다.

<br />

### 3) B-Tree 인덱스 성능 영향 요소

1. 인덱스 키 값 크기
    - `페이지` 혹은 `블록` : 디스크에 데이터를 저장하는 가장 기본적인 단위
    - `InnoDB` 스토리지 엔진 페이지 기본 크기 : `16KB`
    - 일반적으로 페이지 당 가질 수 있는 인덱스 키 개수 : `16 * 1024/(16+12) = 585`
    - 키 값의 크기가 2배(32KB)일 때의 한 페이지 당 인덱스 키 개수 : `16 * 1024/(32+12) = 372`
    - 만약 SELECT 쿼리가 레코드 500개 읽어야 한다면 16KB 기준은 1번, 32KB 기준은 2번 읽어야 한다.

> 즉, 하나의 레코드에 저장되는 인덱스의 키가 커질 수록, 메모리에 캐싱할 수 있는 레코드 수가 감소, 결국 메모리 효율 떨어진다.

2. B-Tree 깊이
    - 인덱스 키 값이 늘어남에 따라 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어진다. (depth 증가)
    - 따라서 여러 번 랜덤하게 디스크를 읽어야하고 결국 성능에 영향을 준다.

3. 선택도(기수성)
    - `선택도` : 모든 인덱스 키 값 가운데 유니크한 값의 수
    - 즉, 전체 인덱스 키 값 100개 중 유니크한 값이 10개라면 선택도는 10%이다.
    - 중복이 많을수록 선택도는 낮아진다.

4. 읽어야 하는 레코드 건수
    - 당연하겠지만 인덱스를 타고 레코드를 읽는 것이, 거치지 않고 바로 레코드를 읽는 것보다 비용이 높다.
    - 보통 DBMS 옵티마이저에서 인덱스 통해 레코드 1건 읽는 것이 테이블에서 직접 레코드 1건 읽는 것 보다 4-5배 정도 비용이 더 든다.
        - 즉, 인덱스 통해서 읽게 될 요소가 전체 레코드의 `20-25%` 넘어서면 인덱스보다는 테이블을 필터링 하는 것이 더 효율적이다.

<br />

#### 🔵 언제 하나의 레코드에 저장되는 인덱스의 키가 커지는가 ?

- 컬럼의 데이터타입이 커지거나 / 다중 컬럼 인덱스를 사용할 때

## 1-2. B-Tree 인덱스를 이용하는 방법 (4가지)

<div style="text-align: center;">
   <img src="https://github.com/hjun-park/TIL/assets/70880695/e80942f3-0917-4475-8a0c-5eca6a1b9fb2" width="70%" height="70%">
</div>

> [인덱스Index-정복기-2](https://velog.io/@hyunrrr/%EC%9D%B8%EB%8D%B1%EC%8A%A4Index-%EC%A0%95%EB%B3%B5%EA%B8%B0-2)

### 1) 인덱스 레인지 스캔

- 가장 대표적이고 3개 중 가장 빠른 방법
- 인덱스의 첫 번째 레코드부터 마지막 레코드까지 순차적으로 읽는 방법
- 검색조건에 일치한 레코드를 찾으면 데이터파일로부터 읽어온다 (레코드 한 건마다 랜덤I/O 발생)

#### 🔵 인덱스 레인지 스캔 과정

1. `인덱스 탐색(Index Seek)` : 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음
2. `인덱스 스캔(Index Scan)` : 조건을 만족하는 값이 저장된 위치부터 순차적으로 읽음
3. `테이블 레코드 읽기` : 2번에서 읽은 인덱스 키와 레코드의 주소를 통해 실제 테이블 레코드를 읽음

<br /> 

#### 🔵 커버링 인덱스

- 위 3번 과정이 생략될 수 있는데, 이를 `커버링 인덱스`라고 한다.
- 즉, 직접 레코드를 읽지 않고도 인덱스만으로 원하는 값을 얻을 수 있는 경우를 말한다.

<br />

### 2) 인덱스 풀 스캔

<div style="text-align: center;">
   <img src="https://github.com/hjun-park/TIL/assets/70880695/a28d188a-f2fd-42fa-a24c-3092b9e0b2f2" width="70%" height="70%">
</div>

- 1번과 마찬가지로 인덱스를 사용하지만 인덱스 처음부터 끝까지 읽는 방식
- 예를 들어 인덱스는 (A, B, C)로 걸려 있지만 `WHERE`절로 `B컬럼` 혹은 `C컬럼`으로 검색하는 경우
    - 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아니기 떄문에 `Full Scan` 진행
- 인덱스를 이용하는 거지만 효율적이지도 않고 인덱스의 생성 목적도 아니다.
    - `인덱스 풀 스캔`을 보고 `인덱스를 타지 못한다`라고도 한다.

<br />

### 3) 루스 인덱스 스캔 (Loose Index Scan) (= 인덱스 스킵 스캔)

<div style="text-align: center;">
   <img src="https://github.com/hjun-park/TIL/assets/70880695/a833810c-08d7-4f9a-b131-2dbe789c2ba3" width="70%" height="70%">
</div>

>
출처 : [데이터베이스 인덱스 Index(mu1616)](https://velog.io/@mu1616/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-Index)

- 레인지 스캔과 비슷하게 동작하지만 중간에 필요하지 않는 인덱스 키 값은 `SKIP`하고 넘어간다.
- 주로 `GROUP BY` 혹은 집합 함수 `MAX()` `MIN()` 함수에 대해 최적화 위해 사용
- 루스 인덱스 스캔 사용 위해서 여러 조건을 만족해야 한다.

<br />

### 4) 인덱스 스킵 스캔

<div style="text-align: center;">
   <img src="https://github.com/hjun-park/TIL/assets/70880695/6f409586-232f-4881-b3ec-df48eb4d5cbf" width="70%" height="70%">
</div>

- Mysql 8.0 와서 도입
- 인덱스 스킵 스캔 조건 2가지
    1) WHERE 조건절에 조건이 없는 선행 컬럼의 유니크한 값의 개수가 적어야 한다.
        - 유니크한 값의 개수가 많다면 옵티마이저에서 스캔 시작 지점을 찾는 데 소요되고, 성능이 느려질 수 있다.
        - 예를 들면 인덱스가 `(emp_no, dept_no)` 조합이라면 결국 사원 수(emp_no)만큼 레인지 스캔 시작 지점을 검색해야 한다.
        - 하지만, 인덱스가 성별인 `('M', 'F')` 조합이라면 M과 F 두 개의 값만 검색하면 되기 때문에 사용 가능하다.
    2) 쿼리가 인덱스에 있는 컬럼만으로 처리 가능해야 한다.(커버링 인덱스)
        - ```sql
       SELECT * FROM employees WHERE birth_date >= '1965-02-01';
       ```
        - 인덱스가 `(gender, birth_date)`로 걸려 있지만,
        - SELECT 통해서 모든 컬럼을 가져오기 때문에 `인덱스 스킵 스캔`이 아닌 `풀 테이블 스캔`으로 실행 계획이 설정된다.

## 1-2. 다중 컬럼 인덱스
- 2개 이상의 컬럼으로 구성된 인덱스
- 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다.
  - 마찬가지로 세 번째 컬럼도 있다면 이는 두 번째 컬럼에 의존해서 정렬된다.

## 1-3. B-Tree 인덱스 정렬 및 스캔 방향

### 1) 인덱스 정렬
- 인덱스는 오름차순, 내림차순 섞어서 인덱스 생성이 가능하다 (Mysql 5.7까지는 -1을 곱했지만 8.0부터는 DESC를 사용)
```sql
CREATE INDEX idx_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

### 2) 인덱스 스캔 방향
- 인덱스는 생성 시점에 오름차순, 내림차순이 결정되지만, 인덱스 사용 시점에 따라 스캔 방향이 달라진다.
```sql
-- 정순으로 읽어서 4개를 가져온다.
SELECT * FROM employees WHERE first_name >= 'TIM' 
    ORDER BY first_name ASC LIMIT 4;

-- 역순으로 읽어서 5개를 가져온다.
SELECT * FROM employees
    ORDER BY first_name DESC LIMIT 5;
```

