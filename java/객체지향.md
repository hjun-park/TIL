- [객체지향](#----)
  * [객체지향의 4가지 특성](#------4-----)
    + [1. 캡슐화(Encapsulation)](#1----)
      - [왜 캡슐화를 사용하는가?](#-------------)
      - [인터페이스를 이용한 캡슐화 (팩토리 패턴)](#-----------------------)
    + [2. 추상화](#2----)
      - [추상화의 2가지](#-----2--)


# 객체지향
> [자바의 신](http://www.yes24.com/Product/Goods/42643850)을 참고하였습니다.

- 클래스(Class)
    - "상태"와 "행위"를 갖는 자바의 기본 단위
    - 붕어빵의 형틀과 같은 설계도를 의미
- 상태(state)와 행위(behavior)
    - 상태 : 클래스나 인스턴스
    - 행위 : 메소드
    - 붕어빵 형틀로 만들어 낸 붕어빵들
- 캡슐화(Encapsulation)
- 메시지(Message)
- 객체(Object)
- 상속(Inheritance)
- Overriding
- Overloading
- 다형성(Polymorphism)
- 인터페이스(Interface)

## 객체지향의 4가지 특성

### 1. [캡슐화(Encapsulation)](https://inpa.tistory.com/entry/OOP-%EC%BA%A1%EC%8A%90%ED%99%94Encapsulation-%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89%EC%9D%98-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4)
- 캡슐로 감싸서 그 내부를 안 보이게 하는 정보 은닉의 개념
- 객체의 속성(필드)과 행위(메소드)를 클래스 하나로 묶고 외부로부터 구현 내용은 감춘다.
- `private`, `public`과 같은 접근제어자로 캡슐화 구현 가능하다.
- `업캐스팅`, `인터페이스` 정보 은닉 중 하나의 방법이다.

#### 왜 캡슐화를 사용하는가?
- 캡슐화를 이용해서 필드를 숨기면 바깥의 간섭으로 발생하는 오류 방지
- 남이 만든 클래스를 하나하나 뜯어볼 필요 없이 메소드(행위) 그대로 사용할 수 있다.
  - 이 부분은 `추상화 - 제어 추상화` 개념과 유사하다.

```java
public class BankAccount {
	
  // private로 선언함으로써 외부에서 접근하지 못하게 한다.
  private double balance;
  
  // getter와 deposit으로만 호출해야 balance 필드에 접근 가능
  public double getBalance() {
    return balance;
  }

  /*
   굳이 balance 필드에 직접 접근하지 않아도 
   deposit 메소드(행위)만으로 해결이 가능하다.
   */
  public void deposit(double amount) {
    balance += amount;
  }
}
```

#### 인터페이스를 이용한 캡슐화 (팩토리 패턴)
```java
abstract class Vehicle{
    abstract public void move();
}

// 상속 이용하여 Car 클래스 생성
class Car extends Shape{
    private void car(){
      System.out.println("move car");
    }
	
    public void move(){ 
    	car();
    }
}

// 상속 이용하여 Subway 클래스 생성
class Subway extends Shape{
    private void subway(){
      System.out.println("move subway");
    }
	
    public void move(){ 
    	subway();
    }
}

// Shape에 연관된 자식 객체들을 찍어내는 팩토리라는 클래스를 새로 만든다.
class VehicleFactory{
    // factory method에서는 인터페이스를 return 한다
    public Vehicle factoryCar() { 
    	return new car(); 
    }
    // factory method에서는 인터페이스를 return 한다
    public Vehicle factorySubway() { 
    	return new subway(); 
    }
}
```

```java
public class Practice {

  public void vehicleMethod() {
    // 팩토리 객체를 만들어주고
    VehicleFactory vehicleFactory = new VehicleFactory();

    // 팩토리 메소드로 Vehicle의 자식 객체 생성하도록 한다.
    // 리턴 타입이 Vehicle 이므로 받는 변수 타입도 Vehicle
    Vehicle vehicle = vehicleFactory.factoryCar(); 

    // "move car"
    vehicle.move(); 
  }
}
```
- 팩토리 객체 생성 후 Vehicle의 자식 객체를 생성하였다. `vehicleFactory.factoryCar()`
- 이 때 자식 객체의 생성과 함께 Vehicle 타입으로 반환해서 받았다. 
- 이렇게 하면 인터페이스로 정보 은닉이 가능하며 
- 추후 기존 클래스에 변경사항이 발생하면 변경범위가 적거나 쉬워진다. 
  - -> `유지보수성, 생산성 향상`


<br />

### 2. 추상화
- 객체의 공통적인 속성(상태)와 기능(행위)를 추출하여 파악하는 것 
- 클래스들의 중요하고 공통된 특징을 추출하여 부모 클래스를 선정하는 것 

```java
public interface Vehicle {
	/*
	 사실 우리는 교통수단이 어떻게 움직이는지, 
	 어떤 원리로 멈추는지
	 그 내부 구조에는 관심이 없다.
        */
	void move();
	void stop();
}
```

#### 추상화의 2가지
- `제어 추상화` : 메소드의 작동방식과 같은 내부 로직을 숨김 (은닉과 유사)
- `데이터 추상화` : 간단한 개념으로 일반화 하는 것
  - ex) 자동차와 지하철을 교통수단으로 묶어 이름을 붙이는 것이 데이터 추상화 


<br />

### 3. 상속

### 4. 다형성
