- [객체지향](#----)
  + [키워드](#---)
  * [1. 객체지향의 4가지 특성](#1-------4-----)
    + [1-1. [캡슐화](#1-1-------)
      - [왜 캡슐화를 사용하는가?](#-------------)
      - [인터페이스를 이용한 캡슐화 (팩토리 패턴)](#-----------------------)
    + [1-2. 추상화](#1-2----)
      - [추상화의 2가지](#-----2--)
    + [1-3. [상속](#1-3---)
      - [왜 상속을 사용하는가 ?](#-------------)
      - [예제](#--)
      - [상속에는 문제점이 있는데 이는 추후 정리 예정](#-------------------------)
    + [1-4. [다형성](#1-4----)

# 객체지향
- [자바의 신](http://www.yes24.com/Product/Goods/42643850), [Inpa Dev](https://inpa.tistory.com/) 를 참고하였습니다.

### 키워드
- 클래스(Class)
  - "상태"와 "행위"를 갖는 자바의 기본 단위
  - 붕어빵의 형틀과 같은 설계도를 의미
- 상태(state)와 행위(behavior)
  - 상태 : 클래스나 인스턴스
  - 행위 : 메소드
  - 붕어빵 형틀로 만들어 낸 붕어빵들
- 캡슐화(Encapsulation)
- 메시지(Message)
- 객체(Object)
- 상속(Inheritance)
- Overriding
- Overloading
- 다형성(Polymorphism)
- 인터페이스(Interface)

<br />

## 1. 객체지향의 4가지 특성

### 1-1. [캡슐화(Encapsulation)](https://inpa.tistory.com/entry/OOP-%EC%BA%A1%EC%8A%90%ED%99%94Encapsulation-%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89%EC%9D%98-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4)
- 캡슐로 감싸서 그 내부를 안 보이게 하는 정보 은닉의 개념
- 객체의 속성(필드)과 행위(메소드)를 클래스 하나로 묶고 외부로부터 구현 내용은 감춘다.
- `private`, `public`과 같은 접근제어자로 캡슐화 구현 가능하다.
- `업캐스팅`, `인터페이스` 정보 은닉 중 하나의 방법이다.

#### 왜 캡슐화를 사용하는가?
- 캡슐화를 이용해서 필드를 숨기면 바깥의 간섭으로 발생하는 오류 방지
- 남이 만든 클래스를 하나하나 뜯어볼 필요 없이 메소드(행위) 그대로 사용할 수 있다.
  - 이 부분은 `추상화 - 제어 추상화` 개념과 유사하다.

```java
public class BankAccount {

  // private로 선언함으로써 외부에서 접근하지 못하게 한다.
  private double balance;

  // getter와 deposit으로만 호출해야 balance 필드에 접근 가능
  public double getBalance() {
    return balance;
  }

  /*
   굳이 balance 필드에 직접 접근하지 않아도 
   deposit 메소드(행위)만으로 해결이 가능하다.
   */
  public void deposit(double amount) {
    balance += amount;
  }
}
```

#### 인터페이스를 이용한 캡슐화 (팩토리 패턴)
```java
abstract class Vehicle{
    abstract public void move();
}

// 상속 이용하여 Car 클래스 생성
class Car extends Shape{
    private void car(){
      System.out.println("move car");
    }
   
    public void move(){ 
       car();
    }
}

// 상속 이용하여 Subway 클래스 생성
class Subway extends Shape{
    private void subway(){
      System.out.println("move subway");
    }
   
    public void move(){ 
       subway();
    }
}

// Shape에 연관된 자식 객체들을 찍어내는 팩토리라는 클래스를 새로 만든다.
class VehicleFactory{
    // factory method에서는 인터페이스를 return 한다
    public Vehicle factoryCar() { 
       return new car(); 
    }
    // factory method에서는 인터페이스를 return 한다
    public Vehicle factorySubway() { 
       return new subway(); 
    }
}
```

```java
public class Practice {

  public void vehicleMethod() {
    // 팩토리 객체를 만들어주고
    VehicleFactory vehicleFactory = new VehicleFactory();

    // 팩토리 메소드로 Vehicle의 자식 객체 생성하도록 한다.
    // 리턴 타입이 Vehicle 이므로 받는 변수 타입도 Vehicle
    Vehicle vehicle = vehicleFactory.factoryCar(); 

    // "move car"
    vehicle.move(); 
  }
}
```
- 팩토리 객체 생성 후 Vehicle의 자식 객체를 생성하였다. `vehicleFactory.factoryCar()`
- 이 때 자식 객체의 생성과 함께 Vehicle 타입으로 반환해서 받았다.
- 이렇게 하면 인터페이스로 정보 은닉이 가능하며
- 추후 기존 클래스에 변경사항이 발생하면 변경범위가 적거나 쉬워진다.
  - -> `유지보수성, 생산성 향상`


<br />

### 1-2. 추상화
- 객체의 공통적인 속성(상태)와 기능(행위)를 추출하여 파악하는 것
- 클래스들의 중요하고 공통된 특징을 추출하여 부모 클래스를 선정하는 것

```java
public interface Vehicle {
   /*
    사실 우리는 교통수단이 어떻게 움직이는지, 
    어떤 원리로 멈추는지
    그 내부 구조에는 관심이 없다.
        */
   void move();
   void stop();
}
```

#### 추상화의 2가지
- `제어 추상화` : 메소드의 작동방식과 같은 내부 로직을 숨김 (은닉과 유사)
- `데이터 추상화` : 간단한 개념으로 일반화 하는 것
  - ex) 자동차와 지하철을 교통수단으로 묶어 이름을 붙이는 것이 데이터 추상화


<br />

### 1-3. [상속](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%A9%EC%84%B1Composition-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
- 부모에 선언된 변수, 메소드에 대한 사용권을 갖는 것
- `extends`, `implements` 사용하여 구현한 경우를 말함

#### 왜 상속을 사용하는가 ?
- `재사용성` : 이미 존재하는 클래스의 기능을 재사용함으로써 코드의 중복을 줄일 수 있다.
- `확장성` : 공통적인 부분을 따로 빼서 상위 클래스를 만들면 추후 확장에 용이
- 결국 `유지보수` 잘 하기 위함

#### 예제
```java
/*
    부모 클래스 (애완동물)
    1. 애완동물은 공통적으로 이름이 있다.
    2. 애완동물은 공통적으로 나이를 가진다. 
 */
public class Pet {
    String name;
    int age;
    
    public Pet(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void move() {
        System.out.println("이동");
    }
}

/*
    부모 클래스 (강아지)
    1. 강아지는 이름이 있다. (상속)
    2. 강아지는 나이가 있다. (상속)
    3. 동물 중에서도 강아지는 견종이 있다. (breed 필드)
    4. 동물 중에서도 강아지는 짖는다. (bark 메서드) 
 */
public class Puppy extends Pet {
    String breed;
    
    public Puppy(String name, int age, String breed) {
        super(name, age);
        this.breed = breed;
    }
    
    public void bark() {
        System.out.println("멍멍멍멍멍멍멍");
    }
}

// 상속의 사용
public class Main {
    public static void main(String[] args) {
        Puppy Puppy = new Puppy("낫또", 5, "시바견");
        System.out.println("이름: " + Puppy.name);
        System.out.println("나이: " + Puppy.age);
        System.out.println("견종: " + Puppy.breed);
        Puppy.move();
        Puppy.bark();
    }
}
```

<br /> 

#### 상속에는 문제점이 있는데 이는 추후 정리 예정 


<br />

### 1-4. [다형성](https://inpa.tistory.com/entry/OOP-JAVA%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1Polymorphism-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4#%EC%9E%90%EB%A3%8C%ED%98%95_%EB%8B%A4%ED%98%95%EC%84%B1)
- 같은 자료형에 여러 타입의 데이터를 대입해서 다양한 결과를 얻어내는 성질 
- `Overloading`, `Overriding`, `Upcasting`, `Interface`, `Abstract` 등등이 자바에서 다형성을 이용하는 방법이다.
- `상속 관계`에 있을 때 여러 개의 다른 클래스에서 다양하게 동작하도록 하는 기능을 말함
