- [객체지향](#----)
  + [키워드](#---)
  * [1. 객체지향의 4가지 특성](#1-------4-----)
    + [1-1. [캡슐화]](#1-1-------)
      - [왜 캡슐화를 사용하는가?](#-------------)
      - [인터페이스를 이용한 캡슐화 (팩토리 패턴)](#-----------------------)
    + [1-2. 추상화](#1-2----)
      - [추상화의 2가지](#-----2--)
    + [1-3. [상속]](#1-3---)
      - [왜 상속을 사용하는가 ?](#-------------)
      - [예제](#--)
      - [상속에는 문제점이 있는데 이는 추후 정리 예정](#-------------------------)
    + [1-4. [다형성]](#1-4----)

# 객체지향의 4가지 특징과 5가지 설계원칙
- [자바의 신](http://www.yes24.com/Product/Goods/42643850), [Inpa Dev](https://inpa.tistory.com/) 를 참고하였습니다.

### 키워드
- 클래스(Class)
  - "상태"와 "행위"를 갖는 자바의 기본 단위
  - 붕어빵의 형틀과 같은 설계도를 의미
- 상태(state)와 행위(behavior)
  - 상태 : 클래스나 인스턴스
  - 행위 : 메소드
  - 붕어빵 형틀로 만들어 낸 붕어빵들
- 캡슐화(Encapsulation)
- 메시지(Message)
- 객체(Object)
- 상속(Inheritance)
- Overriding
- Overloading
- 다형성(Polymorphism)
- 인터페이스(Interface)

<br />

# 1. 객체지향의 4가지 특성
- [캡슐화(Encapsulation)](https://inpa.tistory.com/entry/OOP-%EC%BA%A1%EC%8A%90%ED%99%94Encapsulation-%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89%EC%9D%98-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4)
- 추상화(Abstraction)
- [상속(Inheritance)](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%A9%EC%84%B1Composition-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
- [다형성(Polymorphism)](https://inpa.tistory.com/entry/OOP-JAVA%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1Polymorphism-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4#%EC%9E%90%EB%A3%8C%ED%98%95_%EB%8B%A4%ED%98%95%EC%84%B1)

## 1-1. 캡슐화
- 캡슐로 감싸서 그 내부를 안 보이게 하는 정보 은닉의 개념
- 객체의 속성(필드)과 행위(메소드)를 클래스 하나로 묶고 외부로부터 구현 내용은 감춘다.
- `private`, `public`과 같은 접근제어자로 캡슐화 구현 가능하다.
- `업캐스팅`, `인터페이스` 정보 은닉 중 하나의 방법이다.

### 왜 캡슐화를 사용하는가?
- 캡슐화를 이용해서 필드를 숨기면 바깥의 간섭으로 발생하는 오류 방지
- 남이 만든 클래스를 하나하나 뜯어볼 필요 없이 메소드(행위) 그대로 사용할 수 있다.
  - 이 부분은 `추상화 - 제어 추상화` 개념과 유사하다.

```java
public class BankAccount {

  // private로 선언함으로써 외부에서 접근하지 못하게 한다.
  private double balance;

  // getter와 deposit으로만 호출해야 balance 필드에 접근 가능
  public double getBalance() {
    return balance;
  }

  /*
   굳이 balance 필드에 직접 접근하지 않아도 
   deposit 메소드(행위)만으로 해결이 가능하다.
   */
  public void deposit(double amount) {
    balance += amount;
  }
}
```

### 인터페이스를 이용한 캡슐화 (팩토리 패턴)
```java
abstract class Vehicle{
    abstract public void move();
}

// 상속 이용하여 Car 클래스 생성
class Car extends Shape{
    private void car(){
      System.out.println("move car");
    }
   
    public void move(){ 
       car();
    }
}

// 상속 이용하여 Subway 클래스 생성
class Subway extends Shape{
    private void subway(){
      System.out.println("move subway");
    }
   
    public void move(){ 
       subway();
    }
}

// Shape에 연관된 자식 객체들을 찍어내는 팩토리라는 클래스를 새로 만든다.
class VehicleFactory{
    // factory method에서는 인터페이스를 return 한다
    public Vehicle factoryCar() { 
       return new car(); 
    }
    // factory method에서는 인터페이스를 return 한다
    public Vehicle factorySubway() { 
       return new subway(); 
    }
}
```

```java
public class Practice {

  public void vehicleMethod() {
    // 팩토리 객체를 만들어주고
    VehicleFactory vehicleFactory = new VehicleFactory();

    // 팩토리 메소드로 Vehicle의 자식 객체 생성하도록 한다.
    // 리턴 타입이 Vehicle 이므로 받는 변수 타입도 Vehicle
    Vehicle vehicle = vehicleFactory.factoryCar(); 

    // "move car"
    vehicle.move(); 
  }
}
```
- 팩토리 객체 생성 후 Vehicle의 자식 객체를 생성하였다. `vehicleFactory.factoryCar()`
- 이 때 자식 객체의 생성과 함께 Vehicle 타입으로 반환해서 받았다.
- 이렇게 하면 인터페이스로 정보 은닉이 가능하며
- 추후 기존 클래스에 변경사항이 발생하면 변경범위가 적거나 쉬워진다.
  - -> `유지보수성, 생산성 향상`


<br />

## 1-2. 추상화
- 객체의 공통적인 속성(상태)와 기능(행위)를 추출하여 파악하는 것
- 클래스들의 중요하고 공통된 특징을 추출하여 부모 클래스를 선정하는 것

```java
public interface Vehicle {
   /*
    사실 우리는 교통수단이 어떻게 움직이는지, 
    어떤 원리로 멈추는지
    그 내부 구조에는 관심이 없다.
        */
   void move();
   void stop();
}
```

### 추상화의 2가지
- `제어 추상화` : 메소드의 작동방식과 같은 내부 로직을 숨김 (은닉과 유사)
- `데이터 추상화` : 간단한 개념으로 일반화 하는 것
  - ex) 자동차와 지하철을 교통수단으로 묶어 이름을 붙이는 것이 데이터 추상화


<br />

## 1-3. 상속
- 부모에 선언된 변수, 메소드에 대한 사용권을 갖는 것
- `extends`, `implements` 사용하여 구현한 경우를 말함

### 왜 상속을 사용하는가 ?
- `재사용성` : 이미 존재하는 클래스의 기능을 재사용함으로써 코드의 중복을 줄일 수 있다.
- `확장성` : 공통적인 부분을 따로 빼서 상위 클래스를 만들면 추후 확장에 용이
- 결국 `유지보수` 잘 하기 위함

### 예제
```java
/*
    부모 클래스 (애완동물)
    1. 애완동물은 공통적으로 이름이 있다.
    2. 애완동물은 공통적으로 나이를 가진다. 
 */
public class Pet {
    String name;
    int age;
    
    public Pet(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void move() {
        System.out.println("이동");
    }
}

/*
    부모 클래스 (강아지)
    1. 강아지는 이름이 있다. (상속)
    2. 강아지는 나이가 있다. (상속)
    3. 동물 중에서도 강아지는 견종이 있다. (breed 필드)
    4. 동물 중에서도 강아지는 짖는다. (bark 메서드) 
 */
public class Puppy extends Pet {
    String breed;
    
    public Puppy(String name, int age, String breed) {
        super(name, age);
        this.breed = breed;
    }
    
    public void bark() {
        System.out.println("멍멍멍멍멍멍멍");
    }
}

// 상속의 사용
public class Main {
    public static void main(String[] args) {
        Puppy Puppy = new Puppy("낫또", 5, "시바견");
        System.out.println("이름: " + Puppy.name);
        System.out.println("나이: " + Puppy.age);
        System.out.println("견종: " + Puppy.breed);
        Puppy.move();
        Puppy.bark();
    }
}
```

<br /> 

### 상속 문제점
> 상속대신 합성 사용, extends 대신 interface 사용하는 것을 권장
1. 결합도 증가
   1. 컴파일 시점에 부모-자식 관계가 결정되는 IS-A 구조
   2. 런타임에서는 중간에 다른 클래스를 상속하도록 변경 불가
2. 불필요한 기능 상속
   1. 예를 들어 Pet 클래스에 `fly()` 메서드를 추가했을 때 날 수 없는 자식 클래스도 있을 것이다.
   2. overriding 해서 빈 칸으로 두면 되긴 하지만 불필요한 코드가 남게 된다.
3. 부모 클래스 변경 시 자식 클래스도 변경해야 함
   1. 부모 클래스에서 필드를 추가하고 생성자에 해당 필드를 추가했다면 자식도 마찬가지로 추가해야 한다.
4. 클래스 폭발 문제
   1. 새로 만든 클래스에 상속하여 기존 기능 연결, 또 다시 새로 만든 클래스에 방금 만든 클래스 연결, 반복된다면 부모-자식간 강한 결합 생성
   
<br />

### 합성 ?
- 필드를 이용하여 클래스의 인스턴스를 참조하도록 설계
  - `상속`은 기존 클래스를 `extends`를 해서 확장 사용하였음

<br />

### 합성의 특징 
- 상속은 엄격하게 그 관계라고 말하는 IS-A 관계지만, 합성은 HAS-A 관계
  - 상속은 수직관계, 합성은 수평관계
- 상속은 코드 작성 시(컴파일 타임)에 그 관계가 결정되지만, 합성은 실행 시간(런타임)에 동적으로 관계가 결정

<br/ >

### 합성이 무조건 좋은가 ? 합성의 단점은 ?
- 합성의 단점은 관계가 명확하지 않은 두 개체도 연관지을 수 있다. 때문에 그 관계 파악하는 데 시간이 걸린다.
- 설계에 명확하게 IS-A 상하관계에 있다면 상속을 한다.

<br />

### 합성의 예제코드
```java
public class Subject {
	private String subjectName;    // 과목명
    
    public Subject(String name) {
		this.subjectName = name;
    }
	
}

public class Student {
	private Subject subject;    // 필드 사용하여 그 클래스의 인스턴스를 참조하도록 함
    
    public Student(Subject subject) {
		this.subject = subject; // 생성자 초기화 시에 그 관계를 결정짓게 됨
    }
	
	void learn() {
      System.out.println("%s과목 수강\n", subject.subjectName);
    }
}

public class Main {
	public static void main(String[] args) {
		Student learnMathStudent = new Student(new Subject("수학"));
		learnMathStudent.learn();   // 수학과목 수강
		
		Student learnEngStudent = new Student(new Subject("영어"));
		learnEngStudent.learn();    // 영어과목 수강
	}
}
```
- 객체 지향 개념에서 따로 클래스 인스턴스 변수에 저장해서 이용하는 방식이 `합성`이다.
- 합성을 이용한 `Subject` 인스턴스는 자료형이 클래스 뿐만 아니라 `abstract`, `interface`로도 가능하다.



## 1-4. 다형성
- 같은 자료형에 여러 타입의 데이터를 대입해서 다양한 결과를 얻어내는 성질 
- `Overloading`, `Overriding`, `Upcasting`, `Interface`, `Abstract` 등등이 자바에서 다형성을 이용하는 방법이다.
- `상속 관계`에 있을 때 여러 개의 다른 클래스에서 다양하게 동작하도록 하는 기능을 말함

<br />

### 1. `자료형` 다형성

#### 다형성이 없을 때
```java
class Dog {
}

class Cat {
}

class Tortoise {
}

ArrayList<Dog> dog = new ArrayList<>();
dog.add(new Dog("Dog1", 2));
dog.add(new Dog("Dog2", 4));
dog.forEach(System.out::println);

ArrayList<Cat> cat = new ArrayList<>();
cat.add(new Cat("Cat1", 3));
cat.add(new Cat("Cat2", 5));
cat.forEach(System.out::println);

ArrayList<Tortoise> tortoise = new ArrayList<>();
tortoise.add(new Tortoise("Tortoise1", 20));
tortoise.add(new Tortoise("Tortoise2", 40));
tortoise.forEach(System.out::println);
```
- 매 요소를 만들어서 출력해야하기 때문에 코드가 길어진다.

<br /> 

#### `자료형` 다형성 이용
- 강아지, 고양이, 거북이를 애완동물로 묶으면 코드가 짧아진다.
```java
class Pet {
}

class Dog {
}

class Cat {
}

class Tortoise {
}

ArrayList<Pet> pet = new ArrayList<>();
pet.add(new Dog("Dog1", 2));
pet.add(new Dog("Dog2", 4));
cat.add(new Cat("Cat1", 3));
cat.add(new Cat("Cat2", 5));
tortoise.add(new Tortoise("Tortoise1", 20));
tortoise.add(new Tortoise("Tortoise2", 40));
pet.forEach(System.out::println);
```
- 만약 pet이 아닌 각 자식의 전용 메서드를 사용해야 한다면 오버라이딩 한다.
- 혹은 그 요소만 따로 다운캐스팅 하여 사용한다.

<br />

### 2. `매개변수` 다형성
- 자료형 뿐만 아니라 파라미터에도 적용 가능

#### 다형성 적용 X
```java
class Cat {
    String sound = "야옹";
}

class Dog {
    String sound = "멍멍";
}

class Bark {
	// 메소드 오버로딩 이용
    void bark(Cat cat) {
        System.out.println(cat.sound);
    }

    void bark(Dog dog) {
        System.out.println(dog.lang);
    }
}

public class Main {
    public static void main(String[] args) {

        Cat cat = new Cat();
        Dog dog = new Dog();

        Bark bark = new Bark();
        bark.bark(cat); // 야옹
        bark.bark(dog); // 멍멍
    }
}
```
- 오버로딩을 이용하여 구현했다.
- 추후에 Tortoise 클래스가 추가된다면 코드를 더 추가해야 할 것이다. (번거로움)
- 추후에 Cat 클래스가 지워진다면 Bark 클래스에서도 제거해야 할 것이다. (번거로움)

<br />

#### `매개변수` 다형성 적용
```java
interface Pet {
    void bark();
}

class Cat implements Pet {
    String sound = "야옹";

    public void bark() {
        System.out.println(this.sound);
    }
}

class Dog implements Pet {
    String sound = "멍멍";

    public void bark() {
        System.out.println(this.sound);
    }
}

class Bark {
    void bark(Pet pet) {
        pet.bark();
    }
}

public class Main {
    public static void main(String[] args) {

        Cat cat = new Cat();
        Dog dog = new Dog();

        Bark command = new Bark();
        command.bark(cat); // 야옹
        command.bark(dog); // 멍멍
    }
}
```
- Pet 인터페이스를 구현하고 각 클래스마다 인터페이스 구현하도록 한다.
- 애완동물 인터페이스를 구현한 클래스들로 구성한 결과 
  - `Bark` 클래스의 메서드를 `Pet` 타입 메서드로 받을 수 있게 되었다. 

<br />

### 3. `메서드` 다형성
- `Override`, `Overloading` 도 다형성을 이용한 특징이다.

<br />


## 2. 객체지향의 5가지 원칙 SOLID 

### 1. 단일 책임 원칙 - SRP (Single Responsibility Principle)
> 한 클래스는 하나의 책임만 가진다
- 클라이언트 객체는 직접 구현 객체를 생성하고, 연결하고, 실행하는 다양한 책임을 가지고 있음
- SRP 단일 책임 원칙을 따르면서 관심사를 분리함
- 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당
- 클라이언트 객체는 실행하는 책임만 담당
```markdown
클라이언트객체 : OrderServiceImpl 같은 것들

구현객체를 생성, 연결, 실행 책임은 아래와 같다.
public class OrderServiceImpl implements OrdserService {
	private final FixDiscountPolicy fixDiscountPolicy = new FixDiscountPolicy();
	private final RateDiscountPolilcy rateDiscountPolicy = new RateDiscountPolicy();
}

여기서보면 클라이언트가 직접 Fix, Rate를 생성하고 연결까지 하고
서비스 코드에는 이걸 실행까지 하고 있다.

그래서 fix, rate를 DisCountPolicy 인터페이스로 DI를 받게 한다.
그렇게 해서 생성, 연결이라는 관심사는 따로 분리를 했고
이것은 AppConfig가 담당한다.

그래서 그냥 클라이언트 객체는 "실행"하는 책임만 담당하면 된다.
```

<br />

### 2. 의존관계 역전 원칙 - DIP (Dependency Inversion Principle)
> 추상화에만 의존해야지 구체객체에 의존하면 안 된다
- 새로운 할인 정책을 개발하고, 적용하려고 하니 클라이언트 코드도 함께 변경해야 했다. 왜냐하면 기존 클라이언트 코드( OrderServiceImpl )는 DIP를 지키며 DiscountPolicy 추상화 인터페이스에 의존하는 것 같았지만, FixDiscountPolicy 구체화 구현 클래스에도 함께 의존했다.
- 클라이언트 코드가 DiscountPolicy 추상화 인터페이스에만 의존하도록 코드를 변경했다.
- 하지만 클라이언트 코드는 인터페이스만으로는 아무것도 실행할 수 없다.
- AppConfig가 FixDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 의존관계를 주입했다. 이렇게해서 DIP 원칙을 따르면서 문제도 해결했다.

```markdown
AppConfig를 이용해서 DI를 해주었더니 유연성이 높아졌다.
즉, 구체화에 의존하는 것이 아닌 인터페이스에 의존함으로써 가능해졌다.

기존에 할인정책을 수정하기 위해서 클라이언트 객체 OrderServiceImpl를
수정해야만 했다. 하지만 이 경우 OCP에 위배된다.

그래서 인터페이스인 DiscountPolicy를 의존하도록 했고,
AppConfig가 DI를 해 주도록 하였다.

대신 생성해서 주입을 해서 NPE가 발생하지 않게 의존관계를 주입함으로써,
DIP 원칙을 따르도록 했다.
```

<br />

### 3. 개방 폐쇄 원칙 - OCP (Open Closed Principle)
> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함
- 다형성 사용하고 클라이언트가 DIP를 지킴
- 애플리케이션을 사용 영역과 구성 영역으로 나눔
- AppConfig가 의존관계를 FixDiscountPolicy RateDiscountPolicy 로 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 됨
- 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있다!
```markdown
클라이언트 객체인 OrderServiceImpl에 구현체가 아닌
인터페이스인 DiscountPolicy에 의존하도록 하였고
AppConfig가 DI를 하도록 하였다.

그렇게 되면 여러 할인정책들을 새롭게 확장해도 (새로 만들어도)
클라이언트 객체를 수정할 필요가 없으니 변경에 닫혀있다. (OCP 지킴)
```

<br />

### 4. 리스코프 치환 법칙 - LSP (Liskov Substitution Principle)

<br />

### 5. 의존 역전 원칙 - DIP (Dependency Inversion Principle)
