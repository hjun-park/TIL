> ### 출처 : [스프링 입문을 위한 자바 객체 지향의 원리와 이해](http://www.yes24.com/Product/Goods/17350624)

# 스프링 디자인패턴
- 디자인 패턴은 객체지향 중 `상속(extends)` `인터페이스(interface)` `합성(composition)` 을 이용한다.

## 1. 어댑터 패턴(`Adapter Pattern`)
- 서로 다른 인터페이스를 가진 두 클래스를 연결하는 디자인 패턴

<br />

#### 🔵 장점
- 호환성 없는 클래스들을 함께 사용할 수 있는 점이 유용하다.
- 서로 다른 인터페이스를 변환해 주기 때문에 일괄된 방법으로 처리할 수 있다.

<br />

#### 🔵 콘센트 예제
```java
interface ElectricSocket110V {
    String connect();
}

interface ElectricSocket220V {
    String connect();
}

// 첫 번째 콘센트 (110V)
class ElectricSocket110VImpl implements ElectricSocket110V {
    @Override
    public String connect() {
        return "Connected to 110V Electric Socket";
    }
}

// 또 다른 인터페이스를 가지는 두 번째 콘센트 (220V) 
class ElectricSocket220VImpl implements ElectricSocket220V {
    @Override
    public String connect() {
        return "Connected to 220V Electric Socket";
    }
}

// 구현된 어댑터 패턴 (110V <-> 220V 인터페이스 변환)
class ElectricSocketAdapter implements ElectricSocket110V {
    private ElectricSocket220V socket220V;

    // 1. 어댑터는 220V 인스턴스를 받아와서 connect 메서드를 호출한다.
    public ElectricSocketAdapter(ElectricSocket220V socket220V) {
        this.socket220V = socket220V;
    }

    @Override
    public String connect() {
        // 2. 반환된 문자열에서 220V를 110V를 바꿔준다.
        return "Adapter: " + socket220V.connect().replace("220V", "110V");
    }
}

public class Main {
    public static void main(String[] args) {
        // 1. 220V 콘센트 구현체의 `connect`는 직접 호출된다.
        ElectricSocket220V socket220v = new ElectricSocket220VImpl();
        System.out.println(socket220v.connect()); // Output: Connected to 220V Electric Socket

        // 2. 110V 콘센트 구현체의 `connect`는 어댑터를 통해 간접적으로 호출된다.
        ElectricSocket110V adapter = new ElectricSocketAdapter(new ElectricSocket220VImpl());
        System.out.println(adapter.connect()); // Output: Adapter: Connected to 110V Electric Socket
    }
}
```

<br />

## 2. 프록시 패턴(`proxy pattern`)
- 프록시 패턴은 객체의 대리자(대변인) 역할을 하는 객체를 두어, 원래 객체에 직접 접근하지 않고 대리자 통해 간접적으로 접근하는 디자인 패턴
- 즉, `제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴`을 말한다.

<br />

#### 🔵 장점
- `코드 간결화` : 원래 객체에 접근할 수 있는 권한이 없는 경우에도 대리자를 통해 접근할 수 있다.
- `성능 향상` : 원래 객체 생성 비용이 비싼 경우 프록시 패턴을 이용한다면 성능 향상 이점

<br />

#### 🔵 프록시 패턴 예제
```java
// 파일 핸들러 인터페이스
interface FileHandler {
    void write(String fileName, String content);
    String read(String fileName);
}

// 파일을 읽고 쓰는 기능 담당하는 구현체
class FileHandlerImpl implements FileHandler {
    @Override
    public void write(String fileName, String content) {
        // 매우 느린 파일 쓰기 작업
    }

    @Override
    public String read(String fileName) {
        // 매우 느린 파일 읽기 작업
        return "file content";
    }
}

// `FileHandlerImpl`을 대신하여 파일을 읽고 쓰는 proxy 객체
class FileHandlerProxy implements FileHandler {
    private FileHandlerImpl fileHandler = null;

    @Override
    public void write(String fileName, String content) {
        if (fileHandler == null) {
            fileHandler = new FileHandlerImpl();
        }
        fileHandler.write(fileName, content);
    }

    @Override
    public String read(String fileName) {
        if (fileHandler == null) {
            fileHandler = new FileHandlerImpl();
        }
        return fileHandler.read(fileName);
    }
}

public class Main {
    public static void main(String[] args) {
        // 1. 원래 구현체를 생성하는 것이 아닌 proxy 객체 생성
        FileHandler fileHandler = new FileHandlerProxy();

        // 2. 인터페이스로 파일 쓰기 작업
        //    만약 구현체(`FileHandlerImpl`)가 생성되어 있지 않다면
        //    `FileHandlerProxy` 객체가 `FileHandlerImpl` 객체를 생성 후 쓰기 작업을 수행한다.
        fileHandler.write("test.txt", "Hello, world!");

        // 3. 파일 읽기 작업
        String fileContent = fileHandler.read("test.txt");
        System.out.println(fileContent); // Output: file content
    }
}
```

### 208p